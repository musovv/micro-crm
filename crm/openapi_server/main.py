# coding: utf-8

"""
    microCRM

    This API is builded for website. 

    The version of the OpenAPI document: 1.0
    Generated by: https://openapi-generator.tech
"""

import os
from fastapi import FastAPI, Body
from flask import Flask
from starlette.middleware.wsgi import WSGIMiddleware

from crm.openapi_server.apis.default_api import router as DefaultApiRouter
from jwt import (
    ExpiredSignatureError,
    ImmatureSignatureError,
    InvalidAlgorithmError,
    InvalidAudienceError,
    InvalidKeyError,
    InvalidSignatureError,
    InvalidTokenError,
    MissingRequiredClaimError,
)

from starlette import status
from starlette.middleware.base import RequestResponseEndpoint, BaseHTTPMiddleware
from starlette.middleware.cors import CORSMiddleware
from starlette.requests import Request
from starlette.responses import Response, JSONResponse
import crm.openapi_server.apis.auth as auth

app = FastAPI(
    title="microCRM",
    description="This API is builded for website. ",
    version="1.0",
    debug=True
)
flask = Flask(__name__)


class AuthorizeRequestMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next: RequestResponseEndpoint) -> Response:

        if os.getenv('AUTH_ON', 'False') != 'True':
            request.state.user_id = '00000000-1111-2222-3333-6e6ee0cea077'  # FIXME hardcoded user_id for testing
            return await call_next(request)

        if request.url.path in ['/openapi.json']:  # don't authorize openapi.json
            return await call_next(request)
        if request.method == 'OPTIONS':
            return await call_next(request)

        # Fetch the Authorization header
        bearer_token = request.headers.get('Authorization', None)
        if not bearer_token:
            return JSONResponse(status_code=status.HTTP_401_UNAUTHORIZED, content={'message': 'Missing Authorization header'})

        try:
            if len(bearer_token.split(' ')) == 1:  # FIXME why postman sends token without Bearer?
                auth_token = bearer_token
            elif len(bearer_token.split(' ')) == 2:
                auth_token = bearer_token.split(' ')[1].strip()
            else:
                return JSONResponse(status_code=status.HTTP_401_UNAUTHORIZED,
                                    content={'message': 'Invalid Authorization header'})
            token_payload = auth.decode_and_verify_token(auth_token)
        except (
                ExpiredSignatureError,
                ImmatureSignatureError,
                InvalidAlgorithmError,
                InvalidAudienceError,
                InvalidSignatureError,
                InvalidTokenError,
                InvalidKeyError,
                MissingRequiredClaimError
        ) as e:
            return JSONResponse(status_code=status.HTTP_401_UNAUTHORIZED, content={'message': str(e)})
        else:
            if 'sub' not in token_payload:
                return JSONResponse(status_code=status.HTTP_401_UNAUTHORIZED,
                                    content={'message': 'Invalid token, missing sub field'})
            elif token_payload['sub'] == '':
                return JSONResponse(status_code=status.HTTP_401_UNAUTHORIZED,
                                    content={'message': 'Invalid token, sub field is empty'})
            request.state.user_id = token_payload['sub']
            return await call_next(request)


app.add_middleware(AuthorizeRequestMiddleware)
app.add_middleware(CORSMiddleware,
                   allow_origins=['*'],
                   allow_credentials=True,
                   allow_methods=['*'],
                   allow_headers=['*'])



if os.getenv('TG_TEST', False):
    from telegram import personal_tg_webhook
    # app.add_middleware(WSGIMiddleware, app=flask)
    # app.mount("/flask", WSGIMiddleware(flask))

    @DefaultApiRouter.post('/webhook/create_contact')
    async def check_contact(body = Body(None, description="")):
        return await personal_tg_webhook.import_contact(body)   # for testing


app.include_router(DefaultApiRouter)